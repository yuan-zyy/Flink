要实现“多入多出”的任意拓扑，XML 的设计必须支持**多输入引用**和**侧输出流（Side Output）**。在代码层面，我们需要利用 `Map<String, DataStream>` 作为一个“流注册表”，实现算子间的灵活挂载。

以下是一个复杂的编排案例：**读取两个数据源，合并后根据条件分流，最后分别输出到不同的 Sink。**

---

### 1. XML 配置：多流编排 (`complex-job.xml`)

在这个配置中，`joinNode` 消费两个输入，`splitNode` 产生两个输出。

```xml
<job name="MultiStreamJob">
    <source id="orderSrc" type="com.ops.OrderSource" />
    <source id="logSrc" type="com.ops.LogSource" />

    <transform id="unionNode" type="com.ops.MergeOp">
        <inputs>
            <ref>orderSrc</ref>
            <ref>logSrc</ref>
        </inputs>
    </transform>

    <transform id="splitNode" input-ref="unionNode" type="com.ops.SplitOp">
        <outputs>
            <output tag="high-priority" id="vipStream" />
            <output tag="low-priority" id="normalStream" />
        </outputs>
    </transform>

    <sink id="vipSink" input-ref="vipStream" type="com.ops.RedisSink" />
    <sink id="normalSink" input-ref="normalStream" type="com.ops.ConsoleSink" />
</job>

```

---

### 2. 核心逻辑实现

#### A. 处理“多入” (Union 逻辑)

在解析 `inputs` 标签时，我们需要将多个 ID 对应的流合并。

```java
// 引擎解析 Transform 节点时的片段
List<String> inputRefs = node.getInputRefs();
DataStream<JSONObject> mergedStream;

if (inputRefs.size() > 1) {
    // 获取第一个流
    mergedStream = streamMap.get(inputRefs.get(0));
    // 遍历合并后续所有流
    for (int i = 1; i < inputRefs.size(); i++) {
        mergedStream = mergedStream.union(streamMap.get(inputRefs.get(i)));
    }
} else {
    mergedStream = streamMap.get(inputRefs.get(0));
}

```

#### B. 处理“多出” (Side Output 逻辑)

对于分流，业务算子需要实现 `ProcessFunction`，并通过 XML 定义的 `tag` 将数据发往不同的侧输出。

```java
// 1. 业务定义的分流器
public class SplitOp extends ProcessFunction<JSONObject, JSONObject> {
    // 侧输出标签映射
    public static final OutputTag<JSONObject> VIP_TAG = new OutputTag<JSONObject>("high-priority"){};

    @Override
    public void processElement(JSONObject value, Context ctx, Collector<JSONObject> out) {
        if (value.getInteger("level") > 8) {
            ctx.output(VIP_TAG, value); // 走 VIP 通道
        } else {
            out.collect(value); // 走常规通道
        }
    }
}

// 2. 引擎层自动化提取
SingleOutputStreamOperator<JSONObject> mainStream = inputStream.process(new SplitOp());

// 根据 XML 配置的 output tag 提取并注册到 streamMap
for (OutputConfig outConf : node.getOutputs()) {
    DataStream<JSONObject> sideStream;
    if ("default".equals(outConf.getTag())) {
        sideStream = mainStream; 
    } else {
        sideStream = mainStream.getSideOutput(new OutputTag<JSONObject>(outConf.getTag()){});
    }
    // 将分流后的流以 XML 中定义的 id 存入 Map，供下游消费
    streamMap.put(outConf.getId(), sideStream);
}

```

---

### 3. 架构设计总结

通过这种设计，你可以实现如下拓扑结构：

1. **多入 (Multi-Input):**
* **Union:** 直接合并同类型流。
* **Join/Connect:** 在 XML 中增加 `keyBy` 配置，代码层调用 `left.connect(right).flatMap(...)`。


2. **多出 (Multi-Output):**
* **复制流:** 一个 `input-ref` 被多个算子引用，Flink 自动实现数据广播。
* **分流:** 基于 `SideOutput`，业务代码决定数据去向，XML 决定下游谁来接。



---

### 4. 这种模式的“高级感”体现

* **动态参数注入：** XML 节点可以包含 `<properties>`，通过反射调用业务类的 `setProperties()`，实现同一算子类（如 `FilterOp`）通过不同配置（如 `age > 18` 或 `status = 'active'`) 实例化多次。
* **统一监控：** 引擎在 `applyOperator` 时自动注入 `Metric`，你可以通过 XML 的 `id` 直接在 Grafana 看到每个逻辑算子的吞吐量。

**如果需要处理更复杂的“双流 Join”（涉及到时间窗口和状态清理），你是否希望看看如何将 Flink Window 的参数也抽象到 XML 中？**